# JAVA의 배열에는 왜 toString()을 오버라이딩 시키지 않았나?

> 자바에서 배열의 toString() 메서드가 오버라이딩되지 않은 이유는 설계 철학과 배열의 특수성에 기인한다. 배열은 자바에서 특별히 다뤄지는 데이터 구조로, 객체와 비슷하지만 일반적인 클래스와는 다른 방식으로 작동한다.

## 1. 배열의 설계 철학

배열은 자바에서 가장 기본적인 데이터 구조이며, 다른 객체들과 다르게 특수한 형태의 객체로 취급된다. 자바는 배열을 효율적으로 설계하기 위해 배열에 대한 기능을 **별도의 유틸리티 클래스(java.util.Arrays)** 에 집중시켰다. 배열 객체에 자체적으로 많은 메서드를 추가하면 배열의 경량성을 해칠 수 있기 때문에 배열 객체 자체에는 최소한의 기능만 제공된다.

배열은 객체이긴 하지만, 메서드가 많아지면 오히려 메모리 사용량과 성능에 부정적인 영향을 미칠 수 있다. 따라서 복잡한 작업은 Arrays와 같은 유틸리티 클래스로 분리되었다.

## 2. Object 클래스의 설계와 배열
자바에서 모든 클래스는 Object 클래스를 상속받으며, 배열 역시 예외는 아니다. 기본적으로 Object 클래스의 toString() 메서드는 클래스 이름 + @ + 해시코드를 반환한다.

배열은 이러한 기본 구현을 따르고 있으며, 배열만을 위해 toString()을 별도로 오버라이딩하지 않았다. 이는 배열의 특별한 특성 때문이다.

- 배열은 고정된 구조로 사용되며, 객체처럼 동작하지 않습니다.
- 배열은 일반적인 객체보다 효율성과 단순함이 중요합니다.

## 3. toString() 오버라이딩의 필요성

배열의 내용을 출력하려는 경우는 일반적으로 디버깅이나 로깅 상황에 국한된다. 자바는 이런 작업을 위해 Arrays.toString() 및 Arrays.deepToString() 메서드를 제공한다. 배열이 특별한 데이터 구조인 만큼, 자바 개발자들은 이런 작업을 별도의 유틸리티 클래스에서 처리하는 것이 적합하다고 판단했다.

## 4. 유틸리티 클래스와의 역할 분리

자바는 **SRP(Single Responsibility Principle, 단일 책임 원칙)** 에 따라 배열 객체와 배열 처리 로직을 분리했습니다. 배열 자체는 데이터를 저장하는 역할만 담당하고, 데이터 표현과 같은 부가적인 작업은 Arrays 유틸리티 클래스가 담당한다.

- Arrays.toString(): 1차원 배열의 요소를 문자열로 변환한다.
- Arrays.deepToString(): 다차원 배열을 포함한 배열의 모든 내용을 문자열로 변환한다.
```java
int[] arr = {1, 2, 3};
System.out.println(Arrays.toString(arr));  // [1, 2, 3]
```

## 5. 일관성 있는 설계 유지

배열에 대해 toString()을 오버라이딩하게 되면, 다른 모든 기본 객체에서도 비슷한 처리가 필요하다. 하지만 자바는 배열과 객체를 다르게 다루며, 배열의 toString()을 오버라이딩하면 이런 설계 철학과의 충돌이 발생할 수 있다.

배열은 단순히 데이터를 저장하고, 그 표현은 유틸리티 클래스에서 담당하는 방식이 더 일관성이 있다.
객체에서는 커스텀 toString() 메서드를 통해 개발자가 직접 포맷을 정의할 수 있도록 했다.

## Recap

자바에서 배열의 toString()이 오버라이딩되지 않은 이유는 배열의 경량성과 효율성을 유지하고, 복잡한 작업을 유틸리티 클래스(Arrays)로 위임하는 객체 지향적 설계 철학 때문이다. 배열에 toString()을 오버라이딩할 필요가 적고, 이미 Arrays.toString()과 같은 유틸리티 메서드가 이 역할을 효과적으로 수행하고 있다.