# "한 번 작성하면 어디서든 실행된다"

> 한 번 바이트코드로 컴파일하면 모든 운영체제에서 JVM만 설치하면 실행할 수 있다.

> C나 C++은 컴파일러를 바꿔야 하거나 플랫폼별로 추가 설정을 해야 하는 반면, 자바는 한 번 컴파일된 바이트코드를 어디서든 동일하게 실행할 수 있어 유지보수와 배포가 간편하다.

## 하드웨어 바꿀때마다 jvm설치하거나 컴파일러를 새로 설치하는건 비슷한 코스트가 드는게 아닌가?

- 하드웨어나 운영체제가 바뀔 때마다 JVM을 새로 설치해야 하는 점은 자바도 컴파일러를 새로 설치하는 C/C++과 비슷한 코스트가 든다. 그러나 자바의 플랫폼 독립성의 강점은 바이트코드의 재사용성과 코드의 이식성에서 비롯되며, 이는 다음과 같은 이유에서 유리하다.

    - 자바는 바이트코드로 한 번만 컴파일하면, 모든 운영체제에서 동일한 코드를 재사용할 수 있다.

    - JVM 설치는 한 번만 이루어지면 되므로, 이후의 모든 자바 프로그램이 그 JVM을 사용하여 실행될 수 있다. 즉, 한 번 설치된 JVM은 지속적으로 재사용 가능해 추가적인 설치 비용이 거의 발생하지 않는다. 반면 C/C++은 각 프로젝트나 각 릴리즈별로 플랫폼에 맞춰 컴파일해야 하므로 배포 프로세스가 더 복잡해질 수 있다.

    > 운영체제 별 API와 라이브러리 차이 : OS마다 사용하는 API나 표준 라이브러리가 다르기 때문에, 코드에 OS별로 조건부 코드를 추가해야 하는 경우가 있다. 예를 들어, Windows에서는 WinAPI를 사용해야 하는데, Linux는 POSIX를 따른다. 이로 인해 코드 내에서 플랫폼별 분기 처리를 해야 하며, 각 플랫폼에 맞는 라이브러리를 링크하고 빌드 과정에서도 이를 반영해야 한다.

    > 패키징과 디스트리뷰션: C/C++로 작성된 애플리케이션은 플랫폼별로 빌드된 실행 파일과 라이브러리를 각각 패키징해야 한다. Windows용 .exe 파일, Linux용 .so 라이브러리, macOS용 .dylib 등이 필요하다. 또한, 특정 OS에서는 동적 라이브러리의 위치나 설치 경로가 다르기 때문에, 패키징과 배포 스크립트를 OS별로 따로 준비해야 할 수 있다.

    -  C/C++는 플랫폼마다 컴파일 과정에서 플랫폼에 따라 미세하게 동작이 달라질 수 있다. 특히 다중 플랫폼을 지원해야 하는 경우, 컴파일 옵션이나 아키텍처에 따라 세부적인 오류가 발생할 수 있다. 자바는 JVM을 통해 바이트코드가 실행되는 환경을 통일하므로, 환경 변화에 따른 잠재적 오류를 크게 줄일 수 있다.

## C 언어는 시스템 호출(system call) 방식이 아키텍처마다 다른데, JVM은 아키텍처별로 그것을 표준화한 것인가?

- JVM은 각 플랫폼의 시스템 호출 방식을 표준적으로 처리할 수 있도록 설계되어 있다. JVM 자체가 운영 체제와 하드웨어에 맞게 구현되며, 내부적으로 각 플랫폼의 시스템 호출을 적절히 처리한다. 이를 통해 Java 코드에서 플랫폼 차이를 신경 쓰지 않아도 된다.

- 예를 들어, 파일 시스템 접근이나 네트워크 통신 같은 작업이 Java 코드로 작성되면, JVM이 해당 플랫폼에 맞는 시스템 호출로 변환하여 실행한다.
Java 표준 라이브러리도 이 작업을 간소화하며, 플랫폼에 따라 동작이 달라질 수 있는 부분을 추상화한다.

## C 언어는 왜 JVM처럼 플랫폼 독립성을 지원하지 않는가?

> C 언어는 설계 철학과 목적이 Java와 다르기 때문이다.

### C 언어의 설계 철학

C는 운영 체제 및 하드웨어를 직접 제어하기 위해 만들어졌다.
시스템 리소스(메모리, 프로세서, IO 등)를 효율적으로 관리할 수 있도록 설계되었으며, 이를 위해 시스템 호출과 하드웨어 동작을 직접 사용할 수 있다.

이로 인해 플랫폼 의존성이 높아진다. 컴파일 과정에서 특정 플랫폼의 기계어로 변환되므로, 다른 플랫폼에서 동일한 동작을 보장하려면 소스 코드를 수정하거나 다시 컴파일해야 한다.

### JVM의 역할과 C의 차이

JVM은 Java 코드의 플랫폼 독립성을 보장하기 위해 각 플랫폼마다 구현되어 있는 "추상 계층"이다.
반면, C는 중간 계층 없이 직접 하드웨어와 OS를 다룬다. 이는 성능 측면에서 이점이 있지만, 플랫폼 독립성에는 제약이 있다.

### 플랫폼 독립성을 고려하지 않음

C가 설계된 시기(1970년대)에는 플랫폼 독립성보다 운영 체제 개발과 하드웨어 효율성이 중요한 목표였다.

Unix 같은 운영 체제를 작성하는 데 사용된 언어인 만큼, 운영 체제와 밀접한 관계를 유지해야 했다.

### 컴파일러와 JVM의 차이

C는 컴파일러가 소스 코드를 특정 플랫폼의 기계어로 변환한다. 이 과정에서 플랫폼의 시스템 호출과 아키텍처에 최적화된다.

Java는 바이트코드를 생성하여 JVM이라는 "가상 기계"를 통해 간접적으로 실행한다. JVM은 이러한 추상화를 제공하는 데 필요한 성능 오버헤드를 감수한다.

## C 언어가 JVM 같은 방식을 채택할 수는 없었나?

> 이론적으로는 가능하지만, C의 설계 목적에 부합하지 않는다.

### 성능 최적화 우선
C는 하드웨어에 최대한 가까운 수준에서 동작하며, 시스템 호출과 명령어를 직접 사용하는 것을 목표로 한다. JVM 같은 추상화 계층은 성능 저하를 초래할 수 있다.

### 역사적 배경
C는 Unix 운영 체제의 구현을 위해 설계되었다. 특정 하드웨어와 OS를 깊이 제어해야 했기에, JVM과 같은 플랫폼 독립 계층을 구현하는 대신, 각 플랫폼에 맞는 수정과 최적화를 선택했다.

## Java처럼 플랫폼 독립성을 가진 C 계열 언어가 있나?

### C# 및 .NET
C#은 Java와 유사하게 바이트코드를 생성하고, .NET 플랫폼에서 실행된다. 이로 인해 다양한 운영 체제에서 동일한 동작을 보장한다.

### LLVM 및 Clang:
LLVM은 플랫폼 독립성을 위해 IR(Intermediate Representation)이라는 중간 코드를 생성한다. 이는 C++을 비롯한 여러 언어에 사용된다.

### Go

Go는 C 계열 언어의 성능과 간결함을 유지하면서도 더 높은 수준의 추상화를 제공하려고 한다.
결론적으로, C 언어는 하드웨어와 OS에 밀접하게 설계되었기 때문에 JVM 같은 플랫폼 독립성을 제공하지 않는 것이 철학적, 역사적, 기술적으로 더 자연스러운 선택이다. Java는 이러한 점을 해결하려고 나온 다른 접근 방식의 언어라고 볼 수 있다.