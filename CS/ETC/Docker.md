# Docker

- 도커는 컨테이너 기술이다.
    - 컨테이너를 생성하고 관리하기 위한 도구
    - 소프트웨어 개발에서의 컨테이너란?
        - 표준화된 소프트웨어 유닛
        - A package of code and dependencies to run that code
        - e.g. nodejs code + the nodejs runtime
        - ** 여기서의 runtime : 프로그램이 실행될 수 있는 환경을 제공하는 것

## 도커는 왜 필요한가?
- 소프트웨어 개발에서 독립적인 표준화된 어플리케이션 패키지를 원하는 이유는?
    - 언제나 같은 실행을 보장하기 위해서
    - 개발 환경과 프로덕션 환경의 동일성을 보장하기 위해서
    - 팀이나 회사에서 프로젝트의 크기가 커졌을때 프로그램의 버전을 서로 맞추기 어려우며, 같은 코드 기반에서 작업을 하기위해 많은 소모값이 있다.
        - 특히나 종속성이 많은 라이브러리들에서 문제가 생길 확률이 높다.
    - 혼자 작업할때도 유용하다. 작업하는 프로젝트가 여러 개인 경우 충돌하는 버전이 있을 수도 있기 때문이다.
        - python2 와 최신 버전이 충돌하는 경우가 있을 수 있다.
        - 작업을 전환할때마다 버전을 삭제하고, 설치하기는 너무 번거롭다.

```javascript

// 예시코드
import express from 'express';

import connectToDatabase from './helpers.mjs'

const app = express();

app.get('/', (req, res) => {
    res.send('<h2>Hi there!</h2>');
})

// node 14버전 이상부터 await을 사용 가능하다.
// 배포 환경이 12, 8 같은 버전의 node라면 해당 코드는 에러를 일으킨다
// 이 문제를 찾는데 시간이 많이 걸릴 수 있다.
// 개발 환경과 실제 프로덕션 환경이 다를 가능성이 존재하고, 
// 이를 해결하기 위해 Container를 이용해 정확한 버전을 실행시킬 수 있다.
await connectToDatabase();

app.listen(3000);
```
## 도커를 공부하기 위해 알아야 할 개념

 1. 프로세스 관리 (Process Management)
    - 도커의 기본적인 개념은 컨테이너라는 독립적인 실행 환경을 만들어 여러 프로세스를 격리시키는 것이다. 따라서, 프로세스가 어떻게 실행되고 관리되는지 이해하는 것이 중요하다
 2. 네임스페이스 (Namespaces)
    - 도커는 리눅스 네임스페이스를 사용하여 프로세스, 네트워크, 파일 시스템 등 다양한 리소스를 격리한다. 각 컨테이너는 다른 컨테이너와 독립적으로 실행되며, 이를 가능하게 하는 핵심 기술이 네임스페이스이다.
 3. 컨트롤 그룹 (Control Groups, cgroups)
    - cgroups는 리눅스 커널 기능으로, 프로세스에 대한 리소스 할당을 관리합니다. 도커는 이 기능을 사용하여 각 컨테이너에 할당된 CPU, 메모리, I/O와 같은 리소스를 제한하고 관리한다.
    - cgroups를 통해 도커는 각 컨테이너가 사용할 수 있는 자원의 양을 조절하며, 과도한 리소스 사용을 방지하고 성능을 최적화합니다.
리소스 제한, 우선순위 설정 등을 공부하는 것이 좋습니다.
 4. 파일 시스템과 가상화
    - 도커는 파일 시스템 격리를 위해 Union File System(예: AUFS, OverlayFS 등)을 사용하여, 여러 이미지와 컨테이너가 공유하는 파일 시스템 구조를 효율적으로 관리합니다.
    - 각 컨테이너는 읽기 전용 이미지와 읽기/쓰기 레이어로 구성된 파일 시스템을 사용하여 독립적인 환경을 구성합니다.
    - 파일 시스템과 가상화 기술에 대한 이해는 도커가 어떻게 여러 컨테이너를 효율적으로 실행하는지 이해하는 데 도움이 됩니다.
 5. 네트워크 (Networking)
    - 도커는 여러 가지 네트워크 드라이버를 제공하여, 각 컨테이너 간의 통신을 관리합니다. 네트워크의 격리, 포트 매핑, DNS 설정 등 다양한 기능을 제공합니다.
    - 컨테이너는 독립적인 네트워크 네임스페이스를 가지며, 서로 다른 네트워크에 속한 컨테이너들 간에는 기본적으로 통신할 수 없습니다.
    - Docker Network (bridge, host, overlay 네트워크 등)와 관련된 개념을 이해하면 도커의 네트워크 구성 방식에 대해 더 잘 알 수 있습니다.
 6. 운영 체제의 커널 (Kernel)
    - 도커는 커널 기반의 가상화 기술을 사용합니다. 즉, 하드웨어 가상화와 달리, 도커는 호스트 운영 체제의 커널을 공유하면서 - 프로세스 격리 및 리소스 할당을 처리합니다.
    - 커널이 어떻게 컨테이너화된 환경에서 다양한 기능을 처리하는지 이해하는 것이 중요합니다.
    - 커널 모듈, 시스템 콜, 컨텍스트 스위칭 등을 이해하는 것이 유용할 수 있습니다.
 7. 시스템 호출 (System Calls)
    - 도커는 컨테이너화된 환경에서 여러 시스템 리소스를 시스템 호출을 통해 관리합니다. 시스템 호출은 운영 체제가 제공하는 서비스와 상호작용하는 주요 방법입니다.
    - 예를 들어, 도커는 컨테이너 내에서 파일 시스템 조작, 프로세스 관리, 네트워크 구성 등의 작업을 수행하기 위해 시스템 호출을 사용합니다.
    - 시스템 콜 인터페이스에 대해 공부하면 도커가 어떻게 리눅스 커널과 상호작용하는지 이해하는 데 도움이 됩니다.

- 즉, 도커는 프로세스를 격리하고, 프로세스에 필요한 컴퓨팅 자원을 독립적으로 할당/격리하여 완벽히 격리된 가상 환경을 구축하게 해준다. 

## 도커 컨테이너의 작동 원리

> https://anweh.tistory.com/67

> https://kjw1313.tistory.com/91

![docker2](images/docekr2.png)

- User+ Kernel 계층을 합쳐서 컨테이너로 만들면 process의 행위가 제한된다. 즉, 독립적으로 새로운 OS를 쓰는 것처럼 작동한다. 
- 도커가 성능이 좋은 이유가 무엇일까?   - ???
   - Host OS 입장에서 커널에서 실행되는 또 하나의 프로세스로 처리된다. 컨테이너로 만들면 자신만 다른 세상에서 떨어진 것처럼 따로 작동하여 격리가 된다. 
   - 결론: 도커 컨테이너의 프로세스라는 것은 Host OS 입장에서 프로세스와 같다. Host 입장에서 프로세스가 죽으면 컨테이너 안의 프로세스도 죽는다. 커널을 공유하는데, 이걸 컨테이너라는 이름으로 격리시킨 것이다. 커널의 OS가 개별적으로 실행되니까 마치 독립 컴퓨터가 하나 더 생긴 것과 같은 현상이 나타난다. 
## VM과 Container

![docker1](images/docker1.png)

- VM은 각 머신마다 OS를 설치해야하기 때문에 낭비가 심하다.
- 하이퍼바이저는 물리적 서버의 리소스(CPU, 메모리, 디스크 등)를 가상 머신에게 할당하고, 각 가상 머신이 실제 하드웨어처럼 동작하도록 관리한다. 이를 통해 여러 운영 체제(OS)가 하나의 물리적인 서버에서 독립적으로 실행될 수 있다.
- 운영체제가 도커를 지원한다면 가상머신이 필요 없을 것이다.
- 가상머신을 사용하지 않는 것이 이상적이다. ??
- 가상 머신 위에서 도커가 실행된다. ??

### Docker Containers
- Low impact on OS, very fast, minimal disk space usage
- Sharing, re-building and distribution is easy
- Encapsulate apps/ environments instead of "whole machines"

### Virtual machines
- Bigger impact on OS, slower, higher disk space usage
- Sharing, re-building and distribution can be challenging
- Encapsulate "whole machines" instead of just apps/ environments

| 항목                        | **도커 컨테이너**                                    | **가상 머신**                                    |
|-----------------------------|---------------------------------------------------|-------------------------------------------------|
| **운영 체제에 미치는 영향**     | OS에 미치는 영향이 적고, 빠르게 실행됨.               | OS에 더 큰 영향을 미치며, 더 많은 리소스를 소모함. |
| **속도**                     | 매우 빠르며, 실행 속도가 빠름.                        | 상대적으로 느림. 가상화된 전체 시스템을 실행하므로 속도가 떨어짐. |
| **디스크 공간 사용**           | 디스크 공간을 적게 사용, 작은 크기의 이미지를 생성.   | 디스크 공간을 많이 사용, 전체 운영 체제를 포함하는 이미지를 생성. |
| **재구성 및 배포**              | 앱 및 환경을 캡슐화하여 쉽게 공유, 재구성 및 배포가 용이. | 전체 머신을 캡슐화하므로 공유 및 배포가 복잡하고 시간이 걸림. |
| **캡슐화 대상**                | 애플리케이션 및 해당 환경만 캡슐화.                    | 전체 머신을 캡슐화 (운영 체제 포함).               |
| **자원 격리**                  | 커널을 공유하지만, 각 컨테이너는 격리된 환경에서 실행.   | 하이퍼바이저가 각각의 가상 머신을 완전히 격리된 독립적인 환경으로 실행. |
| **시작 시간**                  | 매우 빠르게 시작됨.                                   | 시작하는 데 시간이 오래 걸림.                    |
| **OS 커널 공유**               | 호스트 OS의 커널을 공유.                             | 각 가상 머신은 자체 커널을 가짐.                  |
| **보안**                      | 보안 격리가 상대적으로 약할 수 있음.                   | 보안이 더 강력함. 각 가상 머신은 독립적인 운영 체제를 가짐. |
| **애플리케이션 격리**           | 애플리케이션의 격리가 필요하지만, 보통은 공유된 커널을 사용. | 각 가상 머신이 완전히 독립된 환경을 제공하므로 애플리케이션 격리가 강력함. |
| **호스트 시스템 의존성**       | 호스트 OS와 더 밀접하게 연관되어 있으므로, 호스트 OS에 따라 다를 수 있음. | 호스트 시스템과 독립적인 환경에서 실행되므로 호스트 OS와 관계가 적음. |
| **리소스 효율성**               | 리소스를 효율적으로 사용함 (CPU, 메모리, 디스크 등).    | 리소스 소모가 많음 (각 가상 머신에 별도의 운영 체제와 자원이 필요). |
| **사용 사례**                  | 빠른 개발, CI/CD, 마이크로서비스, 애플리케이션 격리 등. | 전체 운영 체제를 필요로 하는 애플리케이션, 레거시 시스템, 높은 보안 요구사항 등이 있는 경우. |
