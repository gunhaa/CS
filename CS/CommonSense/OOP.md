# OOP란?

OOP (Object-Oriented Programming)이란 객체 지향적인 프로그래밍. 즉, C언어같은 절차 지향적인 프로그래밍이 아닌 객체의 관점에서 프로그래밍을 한다는 것이다.

OOP는 객체를 기준으로 코드를 나누어 구현한다. 자바의 경우 그 구성 부분 단위가 클래스이다. 자세히 말하자면 클래스는 설계도고 직접 일을하는 구현체는 인스턴스다.

## 객체 지향은 왜 필요한가?

객체 지향은 클래스마다 필요한 필드를 선언하고, getter와 setter로 구성된 모습으로 해결한다. 바로 특정한 개념의 함수와 자료형을 함께 묶어서 관리하기 위해 탄생한 것!

가장 중요한 점은, 객체 내부에 자료형(필드)와 함수(메소드)가 같이 존재하는 것이다.

도서관리 프로그램을 만들 때, 해당하는 책의 제목, 저자, 페이지와 같은 자료형과 읽기, 예약하기 등 메소드를 '책'이라는 객체에 한번에 묶어서 저장하는 것이 가능해졌다.

이처럼 가능한 모든 물리적, 논리적 요소를 객체로 만드려는 것이 객체지향 프로그래밍이라고 말할 수 있다.

객체지향으로 구현하게 되면, 객체 간의 독립성이 생기고 중복코드의 양이 줄어드는 장점이 있다. 또한 독립성이 확립되면 유지보수에도 도움이 될 것이다.

## 객체지향의 특징(4가지)

### 1. 추상화(Abstraction)

> 불필요한 부분은 숨기고, 중요한 부분만을 노출하는 개념이다. 이를 통해 복잡한 시스템을 간단하게 표현할 수 있으며, 사용자가 필요로 하는 인터페이스만 제공하게 한다.

추상화는 목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념이다.

세상에 있는 것을 본따 클래스를 만들고 그 클래스의 상태와 행동을 부여한 객체를 만든다.

그러나 세상에 모든 것을 다 클래스에 담고 객체를 만드것은 불가능하다. 그래서 추상적으로 생각해 일단 큰틀의 클래스를 구현하고 거기에 최소 이러한 공통적인 요소나 필수 적인 요소는 들어갔으면 하는 바램에서 만든 것이 인터페이스와 추상클래스이다.

이 과정에서 공통적인 요소나 특징을 추출하는 과정이 추상화이다.

예를들어. 벤츠, 아우디, 티코 등등 우리가 생각하는 여러 종류의 자동차가 있다. 이것을 다 클래스화하고 변수와 메서드 등을 개별적으로 만드는 것은 무모한 짓이다. (즉,확장성 때문에 추상화할 필요가 있다.)

따라서 방금 나열한 자동차들의 공통적인 요소나 특징을 추출하는 과정인 추상화를 거쳐 요소를 끄집어 내면 바퀴, 핸들, 차문, 유리창 등 필수적인 부품이 있다.

바퀴는 굴러가고, 핸들은 돌아가고 차문은 열려야한다 공통적인 행동 즉 어떤 차든 필수적으로 필요한 메서드가 추출된다.

이러한 과정이 추상화하는 과정이다. 이렇게 추상적으로 끄집어 낸 개념들을 큰 틀에서 클래스로 만든것이 바로 추상클래스이다.

다시 정리해서 이를 객체와 클래스의 관점에서 보면, 객체들은 실제 그 모습이지만, 클래스는 객체들이 어떤 특징들이 있어야 한다고 정의하는 추상화된 개념이다. 추상화는 객체들의 공통된 특징을 파악해 정의해 놓은 설계 기법이라고 할 수 있다.


### 2. 캡슐화(Encapsulation)

> 객체 내부의 데이터를 외부에서 직접 접근하지 못하게 하여, 객체의 데이터와 메서드를 감추고, 이를 객체의 인터페이스를 통해 접근하도록 한다. 이를 통해 객체 내부 구현을 숨기고, 외부 코드의 영향 없이 변경 가능하게 만든다. 즉, **낮은 결합도를 유지하도록 설게하는 것**이다.

한 곳에서 변화가 일어나도 다른 곳에 미치는 영향을 최소화 시키는 것을 말한다. (객체가 내부적으로 기능을 어떻게 구현하는지 감추는 것!)

결합도가 낮도록 만들어야 하는 이유가 무엇일까? 결합도(coupling)란, 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인가를 나타내는 말이다. 즉, 독립적으로 만들어진 객체들 간의 의존도가 최대한 낮게 만드는 것이 중요하다. 객체들 간의 의존도가 높아지면 굳이 객체 지향으로 설계하는 의미가 없어진다.

우리는 소프트웨어 공학에서 객체 안의 모듈 간의 요소가 밀접한 관련이 있는 것으로 구성하여 응집도를 높이고 결합도를 줄여야 요구사항 변경에 대처하는 좋은 설계 방법이라고 배운다. 이것이 바로 캡슐화와 크게 연관된 부분이라고 할 수 있다.

그렇다면, 캡슐화는 어떻게 높은 응집도와 낮은 결합도를 갖게 할까?
바로 정보 은닉을 활용한다.
외부에서 접근할 필요가 없는 것들은 private으로 접근하지 못하도록 제한을 두는 것이다.
(객체안의 필드를 선언할 때 private으로 선언하라는 말이 바로 이 때문!!)



### 3. 상속(inheritance)

> 기존의 클래스를 재사용하여 새로운 클래스를 만들 수 있는 기능이다. 상속을 통해 코드의 중복을 줄이고, 공통된 기능을 여러 클래스에서 공유할 수 있다.

상속(Inheritance) 은 **기존의 클래스를 재사용**하여 새로운 클래스를 만들 수 있는 기능이다. 상속을 통해 중복된 코드를 줄이고, **공통된 기능**을 여러 클래스에서 공유할 수 있다. 부모 클래스는 공통 속성과 메서드를 정의하며, 자식 클래스는 이를 물려받아 사용할 수 있다. 또한, 자식 클래스는 필요에 따라 부모 클래스의 메서드를 오버라이딩(Overriding) 하여 새로운 기능을 추가하거나 재정의할 수 있다.

- 상속은 **일반화 관계(Generalization)** 라고도 불리며, 여러 객체들이 지닌 공통적인 특성을 하나로 묶어 상위 개념(클래스)을 만드는 과정이다.

상속과 **캡슐화(Encapsulation)** 는 독립적인 개념이지만, 상호보완적으로 작용할 수 있다. 상속은 부모 클래스의 세부 구현을 **자식 클래스에서 재사용**하거나, **필요에 따라 수정**할 수 있도록 한다. 반면에, 캡슐화는 클래스의 세부 내용을 **외부에서 접근하지 못하게** 감추는 역할을 한다.

#### 예시를 통한 설명

상속과 캡슐화의 관계를 쉽게 이해하기 위해, **대리 운전자의 사람 클래스**와 **자동차 클래스**의 예를 들어보자.

- **자동차(Car)** 라는 부모 클래스가 있다고 가정해보자. 이 클래스에는 **운전**에 필요한 공통적인 속성(예: 바퀴의 개수, 연료량)과 메서드(예: `drive()`, `stop()`)가 정의되어 있다.
- 이 **자동차 클래스**를 상속받는 **자식 클래스**로는 **벤츠(Benz)**, **BMW**, **아우디(Audi)** 등이 있을 수 있다. 자식 클래스들은 **자동차 클래스의 공통 기능을 상속**받아 사용하면서, 필요에 따라 자신만의 특성(예: 브랜드 고유의 기능)을 추가할 수 있다.

**캡슐화** 측면에서, 대리 운전자인 **사람 클래스**는 자동차의 구체적인 세부 사항(벤츠, BMW 등)에 대해 알 필요가 없다. 사람 클래스는 단지 자동차를 **운전할 수 있는 기능**만 알면 되며, 구체적인 자동차의 구현은 숨겨져 있다. 이를 통해 새로운 자동차 클래스가 추가되더라도, 사람 클래스에는 영향을 미치지 않게 된다.

#### 결론

**상속**은 기존 클래스의 기능을 **재사용**할 수 있게 하며, **자식 클래스**는 부모 클래스의 기능을 **확장**하거나 **변경**할 수 있다. 이때, **캡슐화**는 자식 클래스의 구체적인 기능을 **외부에서 은닉**하여, 변경에 따른 영향을 최소화한다. 상속과 캡슐화가 결합되면, 상위 클래스는 하위 클래스의 세부 구현을 알 필요 없이 **공통된 기능**을 통해 상호작용할 수 있으며, 이는 **유연한 코드**를 작성하는 데 도움이 된다.
#### 상속 재사용의 단점?

- 상위 클래스(부모 클래스)의 변경이 어려워진다.
    - 부모 클래스에 의존하는 자식 클래스가 많을 때, 부모 클래스의 변경이 필요하다면 이를 의존하는 자식 클래스들이 영향을 받게 된다.
- 불필요한 클래스가 증가할 수 있다.
- 유사기능 확장시, 필요 이상의 불필요한 클래스를 만들어야 하는 상황이 발생할 수 있다.
- 상속이 잘못 사용될 수 있다.
- 같은 종류가 아닌 클래스의 구현을 재사용하기 위해 상속을 받게 되면, 문제가 발생할 수 있다. 상속 받는 클래스가 부모 클래스와 IS-A 관계가 아닐 때 이에 해당한다.


#### 해결책

객체 조립(Composition), 컴포지션이라고 부르기도 한다. 객체 조립은, 필드에서 다른 객체를 참조하는 방식으로 구현된다.
상속에 비해 비교적 런타임 구조가 복잡해지고, 구현이 어려운 단점이 존재하지만 변경 시 유연함을 확보하는데 장점이 매우 크다.
따라서 같은 종류가 아닌 클래스를 상속하고 싶을 때는 객체 조립을 우선적으로 적용하는 것이 좋다.


#### 상속의 사용 시점

IS-A 관계가 성립할 때, 재사용 관점이 아닌 기능의 확장 관점일 때
> IS-A는 객체 지향 프로그래밍에서 두 클래스 간의 관계를 설명하는 용어로, 상속 관계를 나타낸다. 이는 "A는 B다"라는 문장으로 표현될 수 있다. 여기서 A는 자식 클래스(하위 클래스)이고, B는 부모 클래스(상위 클래스)이다. 즉, A가 B의 특성을 물려받는 것을 의미한다.

### 4. 다형성(Polymorphism)

> 동일한 메서드나 연산이 다른 객체에서 다른 방식으로 동작할 수 있도록 하는 개념이다. 즉, 같은 이름의 메서드가 객체에 따라 다르게 동작하게 함으로써 유연한 코드를 작성할 수 있다.

객체 지향의 핵심과도 같은 부분이다.

다형성은, 상속과 함께 활용할 때 큰 힘을 발휘한다. 이와 같은 구현은 코드를 간결하게 해주고, 유연함을 갖추게 해준다.
즉, 부모 클래스의 메소드를 자식 클래스가 오버라이딩해서 자신의 역할에 맞게 활용하는 것이 다형성이다.
이처럼 다형성을 사용하면, 구체적으로 현재 어떤 클래스 객체가 참조되는 지는 무관하게 프로그래밍하는 것이 가능하다.
상속 관계에 있으면, 새로운 자식 클래스가 추가되어도 부모 클래스의 함수를 참조해오면 되기 때문에 다른 클래스는 영향을 받지 않게 된다.


## 객체란?

객체는 프로그래밍에서 데이터와 **그 데이터를 처리하는 메서드(함수)** 를 하나로 묶어놓은 독립적인 단위다. 객체는 우리가 실제 세상에서 관찰할 수 있는 사물이나 개념을 프로그래밍에서 표현하기 위해 사용된다. 객체는 상태(데이터)와 행동(메서드)를 함께 포함하므로, 프로그램의 구성 요소로 사용된다.

## 객체와 인스턴스의 차이는?

인스턴스는 클래스에 의해 생성된 실제 객체를 의미한다. 즉, 클래스라는 설계도를 사용해 만들어진 실제 메모리 상의 객체를 가리킨다. 다른 말로, 클래스는 객체를 만들기 위한 틀이고, 인스턴스는 그 틀에서 실제로 만들어진 각각의 개별 객체다.

### 예상 질문