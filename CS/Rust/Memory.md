
# Stack

- 각각의 함수에 의해 생성된 변수들을 저장하는 프로세스의 메모리영역
- 각 함수의 메모리 정보를 스택 프레임이라고 부른다.
- 스택에 있는 모든 변수들의 크기는 컴파일 시에 알려져야 한다.
- 스택은 제한된 크기를 갖는다(중요)
- 스택의 크기는 아키텍처, 운영체제, 컴파일러 그리고 다른 요소에 의해서 결정된다.
- 무한 재귀에 끝에 도달하게되면 생기는 에러가 스택 오버플로우이다.

# Heap

- 자동으로 관리되지 않는 메모리 영역
- 수동으로 메모리를 할당하고 해제해야한다.
- 해제 작업에 실패하면 메모리 누수로 이어진다.
- 스택의 변수는 할당한 함수에 의해서만 접근할 수 있지만, 힙에있는 것은 프로그램 모든 함수에서 접근 할 수 있다.
- 힙에 할당하는 것은 과도한 비용을 초래할 수 있기때문에 가능하면 힙에 할당하는 것은 피하는 것이 좋다.
- 프로그램이 힙에 할당하고, 해제를 반복하면 힙이 조각나버린다. 새로운 위치에 필요한 공간을 효율적으로 찾는것이 훨씬 어려워져 주의해야한다.
    - 힙 조각화 문제는 Java의 경우 Garbage Collector(GC)가 어느 정도 해결해주지만 해결하지 못할 수도 있다.
    - ex) Java 힙은 연속된 메모리 공간을 필요로 하는데, 조각화로 인해 충분한 크기의 연속된 메모리 블록을 찾지 못하면 OutOfMemoryError가 발생할 수 있다.
    - ex) Old Generation 영역에서 오래된 객체들이 남아 있는 경우(특히, GC 대상이 아닌 객체가 많을 때), 조각화가 발생할 가능성이 크다.
    - 즉 Java의 GC는 힙 조각화를 어느 정도 완화하지만, 완전히 해결하지 못할 수 있다.
- 메모리의 주소를 잃기전에 메모리를 해제해야 메모리 누수가 일어나지 않는다
- ** Rust는 GC가 없지만 unmanaged language가 아닌 java와 같은 managed language 이다.(ownership 이용)

# 스마트 포인터

- 스마트 포인터는 raw pointer를 감싸는 wrapper이다.
- 여러 타입이 있지만, 가장 일반적인 것은 포인터가 범위를 벗어났을 때 그것이 가리키는 메모리를 해제하도록 하는 것이다.