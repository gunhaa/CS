# Closure

> 함수가 선언된 렉시컬 환경을 기억하는 기능이다. 즉, 클로저는 함수와 그 함수가 선언될 당시의 스코프를 함께 저장하여, 함수가 호출될 때 그 스코프에 접근할 수 있게 한다. 클로저는 상태를 유지하고, 정보 은닉 및 프라이빗 변수를 구현하는 데 유용하다.

> 클로저는 JavaScript 고유의 기능이라기보다는 함수형 프로그래밍의 중요한 개념 중 하나로, 많은 함수형 언어에서도 동일하게 지원된다. 클로저는 함수형 언어에서 함수가 1급 객체로 취급되고, 함수가 자신의 환경(스코프)을 기억할 수 있다는 점에서 핵심적인 역할을 한다.

## 렉시컬 스코프

> 변수의 유효 범위(scope)가 그 변수가 선언된 위치에 기반한다는 개념이다. 즉, 함수를 정의한 위치에 따라 어떤 변수에 접근할 수 있는지가 결정된다. 

## 특징 

### 1. 이미 실행이 끝난 스코프를 참조한다. 

실행이 끝난 함수의 스코프는, 더이상 참조가 되지 않는다면 가비지컬렉터에 의해 정리된다.
그러나 클로저의 개념에서는 내부 함수가 해당 스코프를 기억하므로, 실행이 끝난 스코프도 계속 참조되어 사라지지 않는다.

### 2. 1의 특징을 활용한다면 은닉화가 가능하다.

Private 변수의 예시를 생각하면 되겠다.
클로저를 활용한다면 외부에서 상위 환경에 선언한 변수에 직접 접근할 수 없다.
만약 이 변수에 대한 제어를 하고 싶다면, 내부 함수에 get이나 set 등의 인터페이스를 추가해줘야 한다.

### 3. 재사용이 가능하다.

클로저를 이용하면 같은 함수 정의를 공유하면서도, 렉시컬 환경(상위 스코프)가 다른 함수를 생성할 수 있다. 클로저를 생성해주는 함수를 실행시키고 그 반환 값을 각각의 변수에 할당하면 끝이다.

동일한 기능을 하는 통장을 발행해주는 은행을 예로 들면
계좌1, 계좌2, 계좌3 선언할 수 있고 각각 독립된 스코프를 가지므로 독립된 데이터(잔고)를 가지도록 할 수 있다.

```javascript

const outerFunc = () => {
    let money = 0;
    let cnt = 0;
    const innerFunc = (amount) => {
        if(amount){
            money += amount;
            cnt++;
        }
        console.log('계좌 잔액 : ', money);
        console.log('계좌 입금 횟수 :', cnt);
    };
    return innerFunc;
}

const account = outerFunc();
account(10000);
account(10000);
// 계좌 잔액 :  10000
// 계좌 입금 횟수 : 1
// 계좌 잔액 :  20000
// 계좌 입금 횟수 : 2

const account2 = outerFunc();
account2(50000);
account2(30000);
// 계좌 잔액 :  50000
// 계좌 입금 횟수 : 1
// 계좌 잔액 :  80000
// 계좌 입금 횟수 : 2

```

## 클로저와 객체의 장단점

### 클로저

#### 장점
1. 프라이빗 변수 지원: 클로저를 사용하면 변수에 대한 접근을 제한할 수 있어 데이터 은닉이 가능하다. 외부에서 직접 접근할 수 없는 상태를 유지할 수 있다.

2. 상태 유지: 클로저는 내부 함수가 외부 함수의 상태를 유지할 수 있도록 해준다. 함수를 여러 번 호출할 때마다 상태를 변경하거나 유지할 수 있다.

3. 모듈화: 클로저는 관련된 데이터를 그룹화하여 모듈화할 수 있다. 함수와 관련된 상태를 함께 묶어 코드의 재사용성을 높일 수 있다.

4. 함수형 프로그래밍: 클로저는 함수형 프로그래밍 패러다임과 잘 어울리며, 고차 함수나 콜백을 사용할 때 유용하다.

#### 단점

1. 메모리 누수: 클로저가 오래 유지되면 메모리 누수가 발생할 수 있다. 내부 함수가 외부 변수에 대한 참조를 유지하게 되어 가비지 컬렉션이 어려워질 수 있다.

2. 디버깅 어려움: 클로저 내부의 상태를 추적하기 어려워 디버깅이 복잡해질 수 있다. 코드의 흐름이 복잡하게 얽힐 경우, 상태를 이해하기 힘들다.

3. 성능 저하: 클로저는 각 호출마다 새로운 스코프를 생성하므로, 너무 많이 사용하면 성능이 저하될 수 있다.


### 객체

#### 장점

1. 명시적 데이터 은닉: 프라이빗 객체는 데이터 은닉을 명시적으로 구현할 수 있다. 클래스 내에서만 
접근할 수 있는 프로퍼티를 정의할 수 있어 코드의 의도를 분명히 할 수 있다.

2. 정적 타입: 클래스 기반의 구조이기 때문에, 정적 타입 언어에서의 클래스처럼 다룰 수 있어 코드의 가독성과 유지보수성을 높일 수 있다.

3. 기존 객체 모델 통합: 객체 지향 프로그래밍 패러다임과 잘 통합되어, 다른 객체 모델과 함께 사용할 수 있다.

4. 구조적 접근: 클래스 내부에서 명시적으로 메소드와 프로퍼티를 정의하므로, 데이터 구조를 더 잘 이해할 수 있다.

#### 단점

1. 구조적 복잡성: 클로저에 비해 구조가 더 복잡할 수 있으며, 객체를 정의하고 관리해야 하는 추가적인 코드가 필요하다.

2. 상태 관리: 객체의 상태를 관리하기 위해 클래스와 메소드를 사용해야 하므로, 간단한 상태 유지에는 불필요하게 복잡할 수 있다.

3. ES6 이상 필요: 프라이빗 필드는 ES2022(ES13)부터 지원되기 때문에 이전 버전의 JavaScript에서는 사용할 수 없다. 이는 호환성 문제를 초래할 수 있다.



## Recap 

> 요약하자면 클로저는 **프라이빗 변수**를 만드는 방법 중 하나이며, 정말 필요할때 아니면 안쓰는 것이 좋아보인다.